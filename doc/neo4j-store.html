<!DOCTYPE html>

<html>
<head>
  <title>neo4j-store.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>neo4j-store.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/* jslint node: true */</span>
<span class="hljs-meta">'use strict'</span>

<span class="hljs-comment">/**
 * This callback type is called `middlewareCallback` and is displayed as a global symbol.
 *
 * @callback middlewareCallback
 * @param     {Object}  [err] - Error object
 */</span>

<span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>)
<span class="hljs-keyword">var</span> Request = <span class="hljs-built_in">require</span>(<span class="hljs-string">'request'</span>)
<span class="hljs-keyword">var</span> Uuid = <span class="hljs-built_in">require</span>(<span class="hljs-string">'node-uuid'</span>)
<span class="hljs-keyword">var</span> DefaultConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./default_config.json'</span>)
<span class="hljs-keyword">var</span> StatementBuilder = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./lib/statement-builder.js'</span>)

<span class="hljs-keyword">var</span> Q = <span class="hljs-built_in">require</span>(<span class="hljs-string">'q'</span>)

<span class="hljs-keyword">var</span> _storeName = <span class="hljs-string">'neo4j-store'</span>
<span class="hljs-keyword">var</span> _actionRole = <span class="hljs-string">'neo4j'</span>
<span class="hljs-keyword">var</span> _internals = {}

<span class="hljs-comment">/** @function _executeCypher
 *
 *  @summary Runs a query on the graphstore and returns the result.
 *
 *  @since 1.0.0
 *
 *  @param    {Object}  cypher - The query to be answered.
 *  @param    {Object}  params - The parameters required by the query.
 *
 *  @returns  {Promise} The promise of a result.
 */</span>
<span class="hljs-keyword">var</span> _executeCypher = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cypher, params</span>) </span>{
  <span class="hljs-keyword">var</span> _deferred = Q.defer()
  <span class="hljs-keyword">if</span> (_.isEmpty(cypher)) {
    _deferred.resolve([])
  }
  <span class="hljs-keyword">var</span> _json = { statements: [ { statement: cypher, parameters: params } ] }
  <span class="hljs-keyword">var</span> _opts = _.clone(_internals.opts.conn)
  _opts.json = _json
  <span class="hljs-keyword">var</span> _execute = Q.nbind(Request.post, Request)

  _execute(_opts)
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
    <span class="hljs-keyword">var</span> _body = response[<span class="hljs-number">1</span>]
    <span class="hljs-keyword">if</span> (_body) {
      <span class="hljs-keyword">var</span> _errors = _body.errors
      <span class="hljs-keyword">var</span> _results = _body.results
      <span class="hljs-keyword">if</span> (_errors &amp;&amp; !_.isEmpty(_errors)) {
        _deferred.reject(_errors)
      }
      <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> _answer = []
        _results.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
          <span class="hljs-keyword">var</span> _data = result.data
          <span class="hljs-keyword">if</span> (_data) {
            _data.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">entry</span>) </span>{
              <span class="hljs-keyword">var</span> _row = entry.row
              <span class="hljs-keyword">if</span> (_row) {
                <span class="hljs-keyword">if</span> (cypher.indexOf(<span class="hljs-string">' AS '</span>) &gt;= <span class="hljs-number">0</span>) {
                  <span class="hljs-keyword">var</span> _columns = result.columns
                  <span class="hljs-keyword">var</span> _instance = {}
                  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _index <span class="hljs-keyword">in</span> _columns) {
                    _instance[_columns[_index]] = _row[_index]
                  }
                  _answer.push(_instance)
                }
                <span class="hljs-keyword">else</span> {
                  _answer.push(_row[<span class="hljs-number">0</span>])
                }
              }
            })
          }
        })
        _deferred.resolve(_answer)
      }
    }
    <span class="hljs-keyword">else</span> {
      _deferred.resolve()
    }
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
    _deferred.reject({ err: err })
  })

  <span class="hljs-keyword">return</span> _deferred.promise
}

<span class="hljs-comment">/** @function _parseResult
 *
 *  @summary Parses the result returned from Neo4j.
 *
 *  Neo4j only supports storage of primitive types or arrays.  In order to store Dates or Objects we
 *  must first convert them to strings.  This means that we have to convert them back to their original form
 *  before returning them to the client.  That is what this function does.
 *
 *  @since 1.0.0
 *
 *  @param    {Object}  result - The object to be parsed.
 *
 *  @returns  {Object} The parsed object.
 */</span>
<span class="hljs-keyword">var</span> _parseResult = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
  <span class="hljs-keyword">if</span> (_.isPlainObject(result)) {
    _.mapValues(result, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, key</span>) </span>{
      <span class="hljs-keyword">if</span> (_.isString(value)) {
        <span class="hljs-keyword">var</span> _tests = { objPatt: <span class="hljs-regexp">/^~obj~{/</span>, arrPatt: <span class="hljs-regexp">/^~arr~\[/</span> }
        _.mapValues(_tests, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">regex</span>) </span>{
          <span class="hljs-keyword">if</span> (regex.test(value)) {
            <span class="hljs-keyword">try</span> {
              result[key] = <span class="hljs-built_in">JSON</span>.parse(value.slice(<span class="hljs-number">5</span>))
            }
            <span class="hljs-keyword">catch</span> (e) {</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>do nothing, we don’t care</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            }
          }
        })
      }
    })
  }

  <span class="hljs-keyword">return</span> result
}

<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>{
  <span class="hljs-keyword">var</span> _seneca = <span class="hljs-keyword">this</span>

  <span class="hljs-keyword">var</span> _opts = _seneca.util.deepextend(DefaultConfig, options)
  _internals = {
    name: _storeName,
    opts: _opts
  }

  <span class="hljs-keyword">var</span> _act = Q.nbind(_seneca.act, _seneca)

  <span class="hljs-comment">/** @function _performAction
   *
   *  @summary Generates a query and passes it to the graphstore.
   *
   *  Calls the supplied hook to generate a query and passes it to the graphstore for resolution.
   *  Performs the supplied success function if results are returned. This method should be passed
   *  the seneca instance as its context when called.
   *
   *  @since 1.0.0
   *
   *  @param    {String}  hook - The name of the query to be generated.
   *  @param    {Function}  success - The function to be called if the query returns a result.
   *  @param    {Object}  args - The original query arguments.
   *  @param    {middlewareCallback}  next - The next callback in the sequence.
   */</span>
  <span class="hljs-keyword">var</span> _performAction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">hook, success, args, next</span>) </span>{
    <span class="hljs-keyword">var</span> _self = <span class="hljs-keyword">this</span>
    _act({ role: _actionRole, hook: hook, target: store.name }, args)
    .done(
      <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">statementObj</span>) </span>{
        <span class="hljs-keyword">var</span> _cypher = statementObj.query.statement
        <span class="hljs-keyword">var</span> _params = statementObj.query.parameters
        <span class="hljs-keyword">var</span> _context = {
          args: args,
          next: next,
          cypher: _cypher,
          seneca: _self
        }
        _executeCypher(_cypher, _params)
        .done(
          <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
            success.call(_context, result)
          },
          <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
            _seneca.log.error(_cypher, _params, err)
            <span class="hljs-keyword">return</span> next(err, { code: statementObj.operation, tag: args.tag$, store: store.name, query: _cypher, error: err })
          }
        )
      },
      <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
        _seneca.log.error(<span class="hljs-string">'Neo4j '</span> + hook + <span class="hljs-string">' error'</span>, err)
        <span class="hljs-keyword">return</span> next(err, { code: err.operation, tag: args.tag$, store: store.name, error: err.error })
      }
    )
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>the store interface returned to seneca</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> store = {</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>methods required by store interface</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    name: _storeName,

    <span class="hljs-comment">/** @function save
     *
     *  @summary Saves object to database.
     *
     *  Save the data as specified in the entitiy block on the arguments object.
     *
     *  @since 1.0.0
     *
     *  @param    {Object}  args - The arguments.
     *  @param    {Object}  args.ent - The object to be saved.
     *  @param    {middlewareCallback}  next - The next callback in the sequence.
     *
     *  @returns  {Object}  The saved object.
     */</span>
    save: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>to be called with the context of _performAction (= ‘this’)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> _success = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
        <span class="hljs-keyword">var</span> _self = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">var</span> _ent = _self.args.ent.make$(_parseResult(result[<span class="hljs-number">0</span>]))
        _self.seneca.log(_self.args.tag$, _self.cypher, _ent)
        <span class="hljs-keyword">return</span> _self.next(<span class="hljs-literal">null</span>, _ent)
      }
      _performAction.call(_seneca, <span class="hljs-string">'create_save_statement'</span>, _success, args, next)
    },

    <span class="hljs-comment">/** @function load
     *
     *  @summary Loads a single object from the database.
     *
     *  Load first object matching query based on id.
     *
     *  @since 1.0.0
     *
     *  @param    {Object}  args - The arguments.
     *  @param    {Object}  args.q - The query parameters.
     *  @param    {Object}  args.qent - The object to be retrieved.
     *  @param    {middlewareCallback}  next - The next callback in the sequence.
     *
     *  @returns  {Object}  The retrieved object.
     */</span>
    load: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>to be called with the context of _performAction (= ‘this’)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> _success = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">results</span>) </span>{
        <span class="hljs-keyword">var</span> _self = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">if</span> (results[<span class="hljs-number">0</span>]) {
          <span class="hljs-keyword">var</span> _ent = _self.args.qent.make$(_parseResult(results[<span class="hljs-number">0</span>]))
          _self.seneca.log(_self.args.tag$, _self.cypher, _ent)
          <span class="hljs-keyword">return</span> _self.next(<span class="hljs-literal">null</span>, _ent)
        }
        <span class="hljs-keyword">return</span> _self.next(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)
      }
      _performAction.call(_seneca, <span class="hljs-string">'create_load_statement'</span>, _success, args, next)
    },

    <span class="hljs-comment">/** @function list
     *
     *  @summary Return a list of objects based on the supplied query, if no query is supplied then return all objects of that type.
     *
     *  @since 1.0.0
     *
     *  @param    {Object}  args - The arguments.
     *  @param    {Object}  args.q - The query parameters.
     *  @param    {Object}  args.qent - The object to be retrieved.
     *  @param    {middlewareCallback}  next - The next callback in the sequence.
     *
     *  @returns  {Object}  The list of objects.
     */</span>
    list: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>to be called with the context of _performAction (= ‘this’)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> _success = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">results</span>) </span>{
        <span class="hljs-keyword">var</span> _self = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">if</span> (_self.args.q.count$) {
          <span class="hljs-keyword">return</span> _self.next(<span class="hljs-literal">null</span>, results)
        }
        <span class="hljs-keyword">if</span> (_self.args.q.exists$) {
          <span class="hljs-keyword">return</span> _self.next(<span class="hljs-literal">null</span>, (results &gt; <span class="hljs-number">0</span>))
        }
        <span class="hljs-keyword">var</span> _list = []
        results.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
          _list.push(_self.args.qent.make$(_parseResult(result)))
        })
        _self.seneca.log(_self.args.tag$, _self.cypher, <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">return</span> _self.next(<span class="hljs-literal">null</span>, _list)
      }
      _performAction.call(_seneca, <span class="hljs-string">'create_list_statement'</span>, _success, args, next)
    },

    <span class="hljs-comment">/** @function remove
     *
     *  @summary Delete an object based on the supplied query.
     *
     *  @since 1.0.0
     *
     *  @param    {Object}  args - The arguments.
     *  @param    {Object}  args.q - The query parameters.
     *  @param    {Object}  args.qent - The entity to be removed.
     *  @param    {middlewareCallback}  next - The next callback in the sequence.
     *
     *  @returns  {Object}  The deleted object if query contains load$, null otherwise.
     */</span>
    remove: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{
      <span class="hljs-keyword">var</span> _fetch_rows_to_delete = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) </span>{
        <span class="hljs-keyword">var</span> _deferred = Q.defer()
        <span class="hljs-keyword">var</span> _q = args.q
        <span class="hljs-keyword">var</span> _qualifiers = [<span class="hljs-string">'sort$'</span>, <span class="hljs-string">'skip$'</span>, <span class="hljs-string">'limit$'</span>]</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>all$: if true, all matching entities are deleted and none are returned; if false only the first entry in the result set is deleted; default: false
load$: if true, the first matching entry (only, and if any) is the response data; if false, there is no response data; default: false
all$ overrides load$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!_q.all$ &amp;&amp; (!_.has(_q, <span class="hljs-string">'relationship$.data'</span>) || (!_q.relationship$.data.all$))) {
          store.load(args, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, row</span>) </span>{
            <span class="hljs-keyword">if</span> (err) {
              <span class="hljs-keyword">return</span> _deferred.reject(err)
            }
            <span class="hljs-keyword">if</span> (!row) {</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>return an id no-one would ever create</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> _impossibleId = <span class="hljs-string">'~$$$$$$$$~'</span>
              <span class="hljs-keyword">if</span> (_q.relationship$) {
                _q.id = _impossibleId
              }
              <span class="hljs-keyword">else</span> {
                args.q = _impossibleId
              }
              <span class="hljs-keyword">return</span> _deferred.resolve()
            }
            <span class="hljs-keyword">if</span> (_q.load$) {
              args.row = row
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>if we’re not loading all then we must delete the first match we get back. Since this will be the full object (including id) we’ll only match that one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (_q.relationship$) {
              _q.id = row.id
            }
            <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">var</span> _ids = []
              <span class="hljs-keyword">try</span> {
                _ids.push(row.id)
              }
              <span class="hljs-keyword">catch</span> (e) {</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>do nothing, we don’t care</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              }
              args.q = _ids
            }
            <span class="hljs-keyword">return</span> _deferred.resolve()
          })
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!_.isEmpty(_.intersection(<span class="hljs-built_in">Object</span>.keys(_q), _qualifiers)) || (_.has(_q, <span class="hljs-string">'relationship$.data'</span>) &amp;&amp; (!_.isEmpty(_.intersection(<span class="hljs-built_in">Object</span>.keys(_q.relationship$.data), _qualifiers))))) {
          store.list(args, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, results</span>) </span>{
            <span class="hljs-keyword">if</span> (err) {
              <span class="hljs-keyword">return</span> _deferred.reject(err)
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>if we’re not loading all then we must delete the first match we get back. Since this will be the full object (including id) we’ll only match that one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> _ids = []
            <span class="hljs-keyword">if</span> (!_.isArray(results)) {
              results = [results]
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>load$: if true, the first matching entry (only, and if any) is the response data; if false, there is no response data; default: false</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (_q.load$) {
              args.row = results[<span class="hljs-number">0</span>]
            }
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _index <span class="hljs-keyword">in</span> results) {
              <span class="hljs-keyword">try</span> {
                _ids.push(results[_index].id)
              }
              <span class="hljs-keyword">catch</span> (e) {</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>do nothing, we don’t care</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              }
            }
            args.q = _ids
            <span class="hljs-keyword">return</span> _deferred.resolve()
          })
        }
        <span class="hljs-keyword">else</span> {
          _deferred.resolve()
        }
        <span class="hljs-keyword">return</span> _deferred.promise
      }

      _fetch_rows_to_delete(args)
      .done(
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>to be called with the context of _performAction (= ‘this’)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> _success = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">results</span>) </span>{
            <span class="hljs-keyword">var</span> _self = <span class="hljs-keyword">this</span>
            _self.seneca.log(_self.args.tag$, _self.cypher, <span class="hljs-literal">null</span>)
            <span class="hljs-keyword">var</span> _result = _self.args.row || <span class="hljs-literal">null</span>
            <span class="hljs-keyword">return</span> _self.next(<span class="hljs-literal">null</span>, _result)
          }
          _performAction.call(_seneca, <span class="hljs-string">'create_remove_statement'</span>, _success, args, next)
        },
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
          _seneca.log.error(<span class="hljs-string">'Neo4j create_remove_statement error'</span>, err)
          <span class="hljs-keyword">return</span> next(err, { code: err.operation, tag: args.tag$, store: store.name, error: err })
        }
      )
    },

    close: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>do nothing as we’re talking to Neo4j over http - there’s no connection to open or close</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> next()
    },

    native: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>to be called with the context of _performAction (= ‘this’)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> _success = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">results</span>) </span>{
        <span class="hljs-keyword">var</span> _self = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">var</span> _list = []
        results = _.castArray(results)
        results.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
          _list.push(_self.seneca.make$(<span class="hljs-string">'obj'</span>, _parseResult(result)))
        })
        _self.seneca.log(_self.args.tag$, _self.cypher, <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">return</span> _self.next(<span class="hljs-literal">null</span>, _list)
      }
      <span class="hljs-keyword">var</span> _action = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{
        _performAction.call(_seneca, <span class="hljs-string">'handle_native_statement'</span>, _success, args, next)
      }
      next(<span class="hljs-literal">null</span>, { query: _action })
    },

    <span class="hljs-comment">/** @function saveRelationship
     *
     *  @summary Creates a unique relationship between the objects.
     *
     *  The 'from' object matches the id in the supplied qent and the 'to' object(s) match the query parameters.
     *  The relationship details are contained in the 'relationship$' object in the query.
     *
     *  @since 1.0.0
     *
     *  @param    {Object}  args - The arguments.
     *  @param    {Object}  args.q - The query parameters.
     *  @param    {Object}  args.qent - The 'from' object.
     *  @param    {middlewareCallback}  next - The next callback in the sequence.
     *
     *  @returns  {Object}  The list of entities.
     */</span>
    saveRelationship: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>to be called with the context of _performAction (= ‘this’)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> _success = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
        <span class="hljs-keyword">var</span> _self = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">var</span> _ent = _self.seneca.make(<span class="hljs-string">'rel'</span>).make$(_parseResult(result[<span class="hljs-number">0</span>]))
        _self.seneca.log(_self.args.tag$, _self.cypher, _ent)
        <span class="hljs-keyword">return</span> _self.next(<span class="hljs-literal">null</span>, _ent)
      }
      _performAction.call(_seneca, <span class="hljs-string">'create_save_relationship_statement'</span>, _success, args, next)
    },

    <span class="hljs-comment">/** @function updateRelationship
     *
     *  @summary Updates a relationship between objects.
     *
     *  The 'from' object matches the id in the supplied qent and the 'to' object(s) match the query parameters.
     *  The new relationship details are contained in the 'relationship$' object in the query.
     *
     *  @since 1.0.0
     *
     *  @param    {Object}  args - The arguments.
     *  @param    {Object}  args.q - The query parameters.
     *  @param    {Object}  args.qent - The 'from' object.
     *  @param    {middlewareCallback}  next - The next callback in the sequence.
     *
     *  @returns  {Object}  The list of entities.
     */</span>
    updateRelationship: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>to be called with the context of _performAction (= ‘this’)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> _success = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
        <span class="hljs-keyword">var</span> _self = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">var</span> _ent = _self.seneca.make(<span class="hljs-string">'rel'</span>).make$(_parseResult(result[<span class="hljs-number">0</span>]))
        _self.seneca.log(_self.args.tag$, _self.cypher, _ent)
        <span class="hljs-keyword">return</span> _self.next(<span class="hljs-literal">null</span>, _ent)
      }
      _performAction.call(_seneca, <span class="hljs-string">'create_update_relationship_statement'</span>, _success, args, next)
    }
  }

  <span class="hljs-comment">/**
   * Initialization
   */</span>
  <span class="hljs-keyword">var</span> _meta = _seneca.store.init(_seneca, _opts, store)
  _internals.desc = _meta.desc

  <span class="hljs-keyword">var</span> _entityProto
  <span class="hljs-keyword">try</span> {
    _entityProto = _seneca.private$.exports.Entity.prototype
  }
  <span class="hljs-keyword">catch</span> (e) {</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>do nothing, entity not assigned yet….</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  }
  <span class="hljs-keyword">if</span> (_entityProto) {
    <span class="hljs-keyword">var</span> _resolve_id_query = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">qin, ent</span>) </span>{
      <span class="hljs-keyword">var</span> q

      <span class="hljs-keyword">if</span> ((_.isUndefined(qin) || _.isNull(qin) || _.isFunction(qin)) &amp;&amp; ent.id != <span class="hljs-literal">null</span>) {
        q = {id: ent.id}
      }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_.isString(qin) || _.isNumber(qin)) {
        q = qin === <span class="hljs-string">''</span> ? <span class="hljs-literal">null</span> : {id: qin}
      }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_.isFunction(qin)) {
        q = <span class="hljs-literal">null</span>
      }
      <span class="hljs-keyword">else</span> {
        q = qin
      }

      <span class="hljs-keyword">return</span> q
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>extend entity by adding saveRelationship$ as a method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _entityProto.saveRelationship$ = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">qin, cb</span>) </span>{
      <span class="hljs-keyword">var</span> _self = <span class="hljs-keyword">this</span>
      <span class="hljs-keyword">var</span> _si = _self.private$.seneca
      <span class="hljs-keyword">var</span> _qent = _self
      <span class="hljs-keyword">var</span> _q = _resolve_id_query(qin, _self)

      cb = (_.isFunction(qin) ? qin : cb) || _.noop</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>empty query or no relationship gives empty result</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> ((_q == <span class="hljs-literal">null</span>) || (_q[<span class="hljs-string">'relationship$'</span>] == <span class="hljs-literal">null</span>)) {
        <span class="hljs-keyword">return</span> cb()
      }

      _si.act(_self.private$.entargs({ qent: _qent, q: _q, cmd: <span class="hljs-string">'saveRelationship'</span> }), cb)

      <span class="hljs-keyword">return</span> _self
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>extend entity by adding updateRelationship$ as a method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _entityProto.updateRelationship$ = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">qin, cb</span>) </span>{
      <span class="hljs-keyword">var</span> _self = <span class="hljs-keyword">this</span>
      <span class="hljs-keyword">var</span> _si = _self.private$.seneca
      <span class="hljs-keyword">var</span> _qent = _self
      <span class="hljs-keyword">var</span> _q = _resolve_id_query(qin, _self)

      cb = (_.isFunction(qin) ? qin : cb) || _.noop</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>empty query or no relationship gives empty result</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> ((_q == <span class="hljs-literal">null</span>) || (_q[<span class="hljs-string">'relationship$'</span>] == <span class="hljs-literal">null</span>)) {
        <span class="hljs-keyword">return</span> cb()
      }

      _si.act(_self.private$.entargs({ qent: _qent, q: _q, cmd: <span class="hljs-string">'updateRelationship'</span> }), cb)

      <span class="hljs-keyword">return</span> _self
    }
  }

  _seneca.add({ init: store.name, tag: _meta.tag }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{
    <span class="hljs-keyword">return</span> next()
  })

  _seneca.add({ role: _actionRole, hook: <span class="hljs-string">'create_load_statement'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>we don’t want changes to q here onwards to be reflected in the calling code…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> _q = _.cloneDeep(args.q)
    <span class="hljs-keyword">var</span> _statement

    <span class="hljs-keyword">if</span> (!_q.sort$ &amp;&amp; !(_.isArray(_q) || _.isString(_q))) {
      <span class="hljs-keyword">try</span> {
        _q.sort$ = { _id: <span class="hljs-number">-1</span> }
      }
      <span class="hljs-keyword">catch</span> (e) {</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>do nothing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      }
    }
    <span class="hljs-keyword">if</span> (_q.relationship$) {
      <span class="hljs-keyword">var</span> _qent = args.qent</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>should do nothing if no relationship query provided and id not present</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (_.isEmpty(_q.relationship$) &amp;&amp; (_.isNull(_qent.id) || _.isUndefined(_qent.id) || _.isEmpty(_qent.id))) {
        <span class="hljs-keyword">return</span> next(<span class="hljs-literal">null</span>, { query: { statement: <span class="hljs-literal">null</span>, parameters: <span class="hljs-literal">null</span> }, operation: <span class="hljs-string">'load related'</span> })
      }
      _.set(_q, <span class="hljs-string">'relationship$.data.limit$'</span>, <span class="hljs-number">1</span>)
      _statement = StatementBuilder.retrieveRelatedStatement(_qent, _q)
      <span class="hljs-keyword">return</span> next(<span class="hljs-literal">null</span>, { query: _statement, operation: <span class="hljs-string">'load related'</span> })
    }
    _statement = StatementBuilder.loadStatement(args.qent, args.q)
    <span class="hljs-keyword">return</span> next(<span class="hljs-literal">null</span>, { query: _statement, operation: <span class="hljs-string">'load'</span> })
  })

  _seneca.add({ role: _actionRole, hook: <span class="hljs-string">'create_list_statement'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>we don’t want changes to q here onwards to be reflected in the calling code…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> _q = _.cloneDeep(args.q)
    <span class="hljs-keyword">var</span> _statement

    <span class="hljs-keyword">if</span> (!_q.sort$) {
      <span class="hljs-keyword">var</span> _newsort
      <span class="hljs-keyword">if</span> (!_.isArray(_q)) {
        _newsort = { _id: <span class="hljs-number">-1</span> }
      }
      <span class="hljs-keyword">else</span> {
        _newsort = { _id: <span class="hljs-number">1</span> }
      }
      <span class="hljs-keyword">try</span> {
        _q.sort$ = _newsort
      }
      <span class="hljs-keyword">catch</span> (e) {</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>do nothing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      }
    }
    <span class="hljs-keyword">if</span> (_q.relationship$) {
      _statement = StatementBuilder.retrieveRelatedStatement(args.qent, _q)
      <span class="hljs-keyword">return</span> next(<span class="hljs-literal">null</span>, { query: _statement, operation: <span class="hljs-string">'list related'</span> })
    }
    _statement = StatementBuilder.listStatement(args.qent, _q)
    <span class="hljs-keyword">return</span> next(<span class="hljs-literal">null</span>, { query: _statement, operation: <span class="hljs-string">'list'</span> })
  })

  _seneca.add({ role: _actionRole, hook: <span class="hljs-string">'create_save_statement'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{
    <span class="hljs-keyword">var</span> _ent = args.ent</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>If the entity has an id field this is used as the primary key by the underlying database and the save is considered an update operation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> _shouldMerge = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">if</span> (options.merge !== <span class="hljs-literal">false</span> &amp;&amp; _ent.merge$ === <span class="hljs-literal">false</span>) {
      _shouldMerge = <span class="hljs-literal">false</span>
    }
    <span class="hljs-keyword">if</span> (options.merge === <span class="hljs-literal">false</span> &amp;&amp; _ent.merge$ !== <span class="hljs-literal">true</span>) {
      _shouldMerge = <span class="hljs-literal">false</span>
    }

    <span class="hljs-keyword">var</span> _update = (!!_ent.id &amp;&amp; _shouldMerge)
    <span class="hljs-keyword">var</span> _statement

    <span class="hljs-keyword">if</span> (_update) {
      _statement = StatementBuilder.updateStatement(_ent)
      <span class="hljs-keyword">return</span> next(<span class="hljs-literal">null</span>, { query: _statement, operation: <span class="hljs-string">'update'</span> })
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>If the entity has an id$ field this is used as the primary key and the save is considered to be an insert operation using the specified key.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (_ent.id$) {
      _ent.id = _ent.id$
      _statement = StatementBuilder.saveStatement(_ent)
      <span class="hljs-keyword">return</span> next(<span class="hljs-literal">null</span>, { query: _statement, operation: <span class="hljs-string">'save'</span> })
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>If the entity does not have an id field one must be generated and the save is considered an insert operation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!_ent.id) {
      _act({ role: _actionRole, hook: <span class="hljs-string">'generate_id'</span>, target: args.target })
      .done(
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
          _ent.id = result.id
          _statement = StatementBuilder.saveStatement(_ent)
          <span class="hljs-keyword">return</span> next(<span class="hljs-literal">null</span>, { query: _statement, operation: <span class="hljs-string">'save'</span> })
        },
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
          _seneca.log.error(<span class="hljs-string">'hook generate_id failed'</span>)
          <span class="hljs-keyword">return</span> next(err)
        }
      )
    }
    <span class="hljs-keyword">else</span> {
      _statement = StatementBuilder.saveStatement(_ent)
      <span class="hljs-keyword">return</span> next(<span class="hljs-literal">null</span>, { query: _statement, operation: <span class="hljs-string">'save'</span> })
    }
  })

  _seneca.add({ role: _actionRole, hook: <span class="hljs-string">'create_remove_statement'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{
    <span class="hljs-keyword">var</span> _q = args.q
    <span class="hljs-keyword">var</span> _statement</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>we remove nodes based on id, so we don’t need to provide a label (and in some cases we don’t want to)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> _unlabelled = _seneca.make$()

    <span class="hljs-keyword">if</span> (_q.relationship$) {
      _statement = StatementBuilder.removeRelationshipStatement(_unlabelled, args.q)
      <span class="hljs-keyword">return</span> next(<span class="hljs-literal">null</span>, { query: _statement, operation: <span class="hljs-string">'remove relationship'</span> })
    }
    _statement = StatementBuilder.removeStatement(_unlabelled, args.q)
    <span class="hljs-keyword">return</span> next(<span class="hljs-literal">null</span>, { query: _statement, operation: <span class="hljs-string">'remove'</span> })
  })

  _seneca.add({ role: _actionRole, hook: <span class="hljs-string">'create_save_relationship_statement'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{
    <span class="hljs-keyword">var</span> _statement = StatementBuilder.uniqueRelationshipStatement(args.qent, args.q)
    <span class="hljs-keyword">return</span> next(<span class="hljs-literal">null</span>, { query: _statement, operation: <span class="hljs-string">'save relationship'</span> })
  })

  _seneca.add({ role: _actionRole, hook: <span class="hljs-string">'create_update_relationship_statement'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{
    <span class="hljs-keyword">var</span> _statement = StatementBuilder.updateRelationshipStatement(args.qent, args.q)
    <span class="hljs-keyword">return</span> next(<span class="hljs-literal">null</span>, { query: _statement, operation: <span class="hljs-string">'update relationship'</span> })
  })

  _seneca.add({ role: _actionRole, hook: <span class="hljs-string">'handle_native_statement'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{
    <span class="hljs-keyword">var</span> _statement = { statement: args.cypher, parameters: args.parameters }
    <span class="hljs-keyword">return</span> next(<span class="hljs-literal">null</span>, { query: _statement, operation: <span class="hljs-string">'native'</span> })
  })

  _seneca.add({ role: _actionRole, hook: <span class="hljs-string">'generate_id'</span>, target: store.name }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args, next</span>) </span>{
    <span class="hljs-keyword">return</span> next(<span class="hljs-literal">null</span>, { id: Uuid() })
  })

  <span class="hljs-keyword">return</span> { name: store.name, tag: _meta.tag }
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
